# For Capstone Design
### A* Algorithm for Optimal Intra-bay Container Pre-marshalling Plan
Flask 웹 애플리케이션을 사용하여 컨테이너 배치 문제를 해결하는 프로그램. 컨테이너를 적절히 재배치하고, 각 단계의 과정을 기록하며, 최적의 배치와 이동 횟수를 찾는 알고리즘 기능을 제공한다. 

## **Consideration**

Input 

```
A = [
        [2, 1],
        [2, 3],
        [2, 3]
    ]   
    
    W = 3
    H = 3
```

1. 작은 인덱스 위에 큰 인덱스를 옮길 수 없다.
2. 주어진 W와 H를 맞추기 위해 빈자리는 0으로 채운다.
3. 0은 빈자리 이므로 옮길 수 없다.
4. 각 stack의 0 뒤에는 어떠한 컨테이너도 올 수 없다.
5. 옮길때 마다 각 스택이 내림차순으로 정렬되어 있는지 검증하고 다시 재배치를 시작한다.
6. 1회 재배치 시, 가장 오른쪽에 있는 컨테이너(’인덱스’:’값’)만 옮길 수 있다.
7. 가장 뒤에 있는 컨테이너 중 가장 인덱스가 큰 컨테이너를 우선으로 주어진 0(빈자리) 중에 배치한다. (가중치 부여)
8. 맨 아래에 있는 0에는 가장 인덱스가 큰 컨테이너를 우선으로 가장 큰 것을 선택한다. (가중치 부여)
9. 각 열의 가장 오른쪽에 있는 0이 아닌 값만을 이동할 수 있다.
10. 각 열의 가장 오른쪽에 있는 값이 아니면 이동할 수 없다.
11. 이동할 때, 왼쪽에(밑) 0값이 있으면 이동할 수 없다.
12. 같은 행 끼리는 컨테이너를 옮길 수 없다.
13. 1회 재배치 시, 마지막으로 옮긴 컨테이너를 제외하고 옮길 컨테이너를 선택한다.

------------
이제 앞서 구현했던 적합 상태로 만드는 코드를 여러번 실행시켜서 최소로 이동하는 경로를 구해보는 것이 목표이다.


#### 결과

지금은 3by3의 구조라서 휴리스틱 방법으로 5번이 최적인데, 10번의 시도한에 최적 경로를 구하는 것을 볼 수 있다.

```
Trial 1:
########## Final State ##########
Move count: 6

Trial 2:
########## Final State ##########
Move count: 5

Trial 3:
########## Final State ##########
Move count: 51

Trial 4:
########## Final State ##########
Move count: 10

Trial 5:
########## Final State ##########
Move count: 7

Trial 6:
########## Final State ##########
Move count: 21

Trial 7:
########## Final State ##########
Move count: 20

Trial 8:
########## Final State ##########
Move count: 8

Trial 9:
########## Final State ##########
Move count: 10

Trial 10:
########## Final State ##########
Move count: 12

Best result with the least move count:
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]
Minimum Move count: 5

Process log of the best result:
Step 0: Initial state
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]

Step 1: [('e', 3)] to (2, 2). Move count: 1
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]

Step 2: [('d', 2)] to (0, 2). Move count: 2
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]

Step 3: [('e', 3)] to (1, 0). Move count: 3
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]

Step 4: [('h', 3)] to (1, 1). Move count: 4
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]

Step 5: [('d', 2)] to (2, 1). Move count: 5
[{'a': 2}, {'b': 1}, {'i': 0}]
[{'e': 3}, {'h': 3}, {'f': 0}]
[{'g': 2}, {'d': 2}, {'c': 0}]
```
--------


#### 각 함수 설명

주요 함수와 코드 블록은 다음과 같다.

1. adjust_matrix_and_add_identifiers(A, W, H)
•	기능: 주어진 컨테이너 배열 A를 좌표를 키로 사용하는 딕셔너리 형식으로 변환한다.
•	설명:
o	A: 원본 컨테이너 배열
o	W, H: 배열의 너비와 높이
o	각 요소에 좌표 (i,j)를 키로 가지는 딕셔너리로 변환한다.
2. find_moving_container(A, last_moved_container)
•	기능: 옮길 컨테이너를 선택한다.
•	설명:
o	A: 딕셔너리 형태의 컨테이너 배열
o	last_moved_container: 마지막으로 이동한 컨테이너의 위치
o	최상단에 있는 컨테이너 중에서 가장 우선순위가 낮은 것을 선택하여 다음 이동할 컨테이너로 설정한다.
3. find_valid_empty_slot(A, moving_con_col)
•	기능: 선택된 컨테이너가 이동할 빈 자리를 찾는다.
•	설명:
o	A: 딕셔너리 형태의 컨테이너 배열
o	moving_con_col: 선택된 컨테이너가 위치한 열
o	현재 열이 아닌 다른 열에 빈 자리를 찾는다. 아래에 있는 자리가 비어 있으면 유효하지 않은 자리로 간주한다.
4. is_sorted_ascending(column)
•	기능: 모든 스택이 적합한지 확인한다.
•	설명:
o	column: 확인할 열이다.
o	모든 값이 오름차순으로 정렬되어 있는지 확인한다.
5. move_and_sort(A, W, H)
•	기능: 1, 2, 3, 4를 실행하여 컨테이너를 이동하여 정렬하고, 각 단계의 과정을 기록한다.
•	설명:
o	초기 상태를 저장하고, 컨테이너를 이동시켜 최적 순으로 정렬한다.
o	각 단계의 상태와 이동 횟수를 기록하여 반환한다.
6. run_experiments(num_trials, A, W, H)
•	기능: 여러 번의 실험을 통해 최적의 이동 횟수와 배치를 찾는다.
•	설명:
o	num_trials: 실험 횟수
o	각 실험에서 컨테이너를 이동시켜 최적 재정돈 상태를 찾고, 최소 이동 횟수를 기록한다.
7. prettify_matrix(matrix)
•	기능: 웹에서 배열을 표 형태로 볼 수 있게 변환한다.
•	설명:
o	matrix: 변환할 배열
o	각 요소를 JSON 형식으로 변환하여 가독성을 높인다.
8. index()
•	기능: 웹 애플리케이션의 메인 페이지를 반환한다.
•	설명:
o	index.html 템플릿을 렌더링하여 반환한다.
9. process()
•	기능: 클라이언트로부터 데이터를 받아 컨테이너 배치를 처리한다.
•	설명:
o	POST 요청을 통해 배열 A, 너비 W, 높이 H를 받는다.
o	run_experiments 함수를 호출하여 최적의 배치와 이동 횟수를 계산한다.
o	결과와 CPU 시간을 JSON 형태로 클라이언트에게 반환한다.
10. 애플리케이션 실행
•	기능: 애플리케이션을 실행한다.
•	설명:
o	if __name__ == '__main__': 블록은 이 스크립트가 메인 프로그램으로 실행될 때 Flask 애플리케이션을 디버그 모드로 실행한다.
전반적인 흐름
1.	클라이언트가 /process 엔드포인트로 POST 요청을 보낸다.
2.	서버는 요청에서 컨테이너 배열과 크기 정보를 받아온다.
3.	run_experiments 함수를 통해 컨테이너 최적 재정돈 상태와 이동 횟수를 계산한다.
4.	결과를 JSON으로 변환하여 클라이언트에 응답한다.

